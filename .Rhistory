apply(phdatdz_e,2,var)[i2]
round(cor(phdatdz_e),3)[i2,i2]
#
#
#
# [1] "pht1"   "pht2"   "pgsm"   "pgsf"   "pgst1"  "pgsnt1" "pgst2"  "pgsnt2" "pgsmf"  "mpgst"
#
# Organize data in long format simulated data long format or vertical format
#
#
# Long format exact simulated data
phdatmzL_e = matrix(1,nmz*2,8)
phdatmzL_e[,2]=nmz + c(c(1:nmz),c(1:nmz))
phdatmzL_e[,3]=c(phdatmz_e$pht1,phdatmz_e$pht2)
phdatmzL_e[,4]=c(phdatmz_e$pgsm,phdatmz_e$pgsm)
phdatmzL_e[,5]=c(phdatmz_e$pgsf,phdatmz_e$pgsf)
phdatmzL_e[,6]=c(phdatmz_e$pgst1,phdatmz_e$pgst2)
phdatmzL_e[,7]=c(phdatmz_e$pgsmf,phdatmz_e$pgsmf)
phdatmzL_e[,8]=c(phdatmz_e$mpgst,phdatmz_e$mpgst)
#
ix_ = sort.int(phdatmzL_e[,2], index.return=TRUE)
phdatmzL_e = phdatmzL_e[ix_$ix,]
colnames(phdatmzL_e)=c("zyg","famnr","ph","pgsm","pgsf","pgst","pgsmf","mpgst")
phdatmzL_e=as.data.frame(phdatmzL_e)
#
#
# Long format exact simulated data
#
phdatdzL_e = matrix(1,ndz*2,8)
phdatdzL_e[,2]=c(c(1:ndz),c(1:ndz))
phdatdzL_e[,3]=c(phdatdz_e$pht1,phdatdz_e$pht2)
phdatdzL_e[,4]=c(phdatdz_e$pgsm,phdatdz_e$pgsm)
phdatdzL_e[,5]=c(phdatdz_e$pgsf,phdatdz_e$pgsf)
phdatdzL_e[,6]=c(phdatdz_e$pgst1,phdatdz_e$pgst2)
phdatdzL_e[,7]=c(phdatdz_e$pgsmf,phdatdz_e$pgsmf)
phdatdzL_e[,8]=c(phdatdz_e$mpgst,phdatdz_e$mpgst)
#
ix_ = sort.int(phdatdzL_e[,2], index.return=TRUE)
phdatdzL_e = phdatdzL_e[ix_$ix,]
colnames(phdatdzL_e)=c("zyg","famnr","ph","pgsm","pgsf","pgst","pgsmf","mpgst")
phdatdzL_e=as.data.frame(phdatdzL_e)
#
phdatL_e=rbind(phdatmzL_e, phdatdzL_e)
# OpenMx covariance structure modeling
vnamesdz=c('pht1','pht2','pgst1','pgst2','pgsm','pgsf')
vnamesmz=c('pht1','pht2','pgst1','pgsm','pgsf')
#
##         1       2    3       4      5      6      7       8  .... 7 and 8 are correlated 1 in MZs
w_mzdat=phdatmz_e[,vnamesmz]
w_dzdat=phdatdz_e[,vnamesdz]
# ==============================================================================================
#
# model covariance matrix:
#  GDFD'G' + Y |  GDFD'
#  FD'G'D      |  DFD'
#
# DFD' is the covariance matrix 2x2 of the parental PGS
# D 2x2 diagonal contains the stds of the parental PGS
# F is the 2x2 correlation matrix of the parental PGS.
#
# G contains the regressions of offspring phenotype on parental and offspring PGS
# Y is the residual phenotypic covariance matrix modeled using ACE model
#
mz1out=4 # remove 8th variable PGS of mz twin 2.
Filter=diag(6)[-mz1out,]
#
RAdz=matrix(c(.5),4,4)
diag(RAdz)=1
RAdz[3,4] <- RAdz[4,3] <- 0# m f assortative mating
RAmz=RAdz
RAmz[1,2]=RAmz[2,1]=1 # MZ twins
RAfree=matrix(FALSE,4,4)
RAlabels=matrix(NA,4,4)
#
M1 <- OpenMx::mxModel("M1",
mxMatrix(type='Full', nrow=5, ncol=6, free=FALSE, values=Filter, labels=c(NA), name='Filter'),
# mean
mxMatrix(type="Full", nrow=1, ncol=6,
#
free=c(TRUE,TRUE,TRUE,TRUE,TRUE,TRUE),
values=c(0,0,0,0,0,0),
labels=c("mph","mph","mpgs","mpgs","mpgs","mpgs"),
name="expMeandz"),
mxAlgebra(expression=(expMeandz%*%t(Filter)), name="expMeanmz"),
# pgs stdevs matrix D
mxMatrix(type="Diag", nrow=4, ncol=4,
free=c(TRUE,TRUE,TRUE,TRUE),
values=c(.7,.7,.7,.7),
labels=c("sdp","sdp","sdp","sdp"), lbound=.01,
name="D"),
# pgs correlation matris F
mxMatrix(type="Symm", nrow=4, ncol=4,
free=RAfree, values=RAdz, labels=RAlabels, name="Fdz"),
mxMatrix(type="Symm", nrow=4, ncol=4,
free=RAfree, values=RAmz, labels=RAlabels, name="Fmz"),
# A matrix for P = A + C + E
mxMatrix(type="Symm", nrow=2, ncol=2,
free=c(FALSE), values=RAdz[1:2,1:2], labels=c(NA), name="Adz"),
mxMatrix(type="Symm", nrow=2, ncol=2,
free=c(FALSE), values=RAmz[1:2,1:2], labels=c(NA), name="Amz"),
# C matrix for P = A + C + E
mxMatrix(type="Symm", nrow=2, ncol=2,
free=c(FALSE), values=c(1), labels=c(NA), name="C"),
# E
mxMatrix(type="Iden", nrow=2, ncol=2, name="E"),
#
# A matrix for P = A + C + E
mxMatrix(type="Symm", nrow=1, ncol=1,
free=c(TRUE), values=c(.33), labels=c("sa2"), name="Av"),
# C matrix for P = A + C + E
mxMatrix(type="Symm", nrow=1, ncol=1,
free=c(TRUE), values=c(.33), labels=c("sc2"), name="Cv"),
# E matrix for P = A + C + E
mxMatrix(type="Symm", nrow=1, ncol=1,
free=c(TRUE), values=c(.33), labels=c("se2"), name="Ev"),
#
mxMatrix(type="Full", nrow=2, ncol=4,
free=matrix(c(
TRUE,TRUE,TRUE,TRUE,
TRUE,TRUE,TRUE,TRUE),2,4,byrow=TRUE),
labels=matrix(c(
'a1','b1','g1','g1',
'b1','a1','g1','g1'),2,4,byrow=TRUE),
values=matrix(c(
.1, 0, .01,.01,
0,.1, .01,.01),2,4,byrow=TRUE), name='G'),
#
mxAlgebra(expression=Av%x%Amz + Cv%x%C + Ev%x%E, name="Ymz"),
mxAlgebra(expression=Av%x%Adz + Cv%x%C + Ev%x%E, name="Ydz"),
mxAlgebra(expression=D%*%Fdz%*%t(D), name="Pdz"),
mxAlgebra(expression=D%*%Fmz%*%t(D), name="Pmz"),
mxAlgebra(expression=G%*%Pdz%*%t(G)+Ydz, name="Sdz1"),
mxAlgebra(expression=G%*%Pmz%*%t(G)+Ymz, name="Smz1"),
#
#   mxAlgebra(expression=G%*%D%*%Pmz, name="GDPmz"),
#   mxAlgebra(expression=G%*%D%*%Pdz, name="GDPdz"),
mxAlgebra(expression=G%*%Pmz, name="GDPmz"),
mxAlgebra(expression=G%*%Pdz, name="GDPdz"),
mxAlgebra(expression=Filter%*%rbind(cbind(Smz1,GDPmz),cbind(t(GDPmz),Pmz))%*%t(Filter), name="Smz"),
mxAlgebra(expression=rbind(cbind(Sdz1,GDPdz),cbind(t(GDPdz),Pdz)), name="Sdz"),
#
mxCI(c('b1','a1','g1'))
#
)
DZ <-  OpenMx::mxModel('DZ',
mxData( observed=w_dzdat, type="raw"),
mxExpectationNormal( covariance="M1.Sdz", means="M1.expMeandz",
dimnames=vnamesdz),  # the fit function
mxFitFunctionML()
)
MZ <-  OpenMx::mxModel('MZ',
mxData( observed=w_mzdat, type="raw"),
mxExpectationNormal( covariance="M1.Smz", means="M1.expMeanmz",
dimnames=vnamesmz),  # the fit function
mxFitFunctionML()
)
#
Model_1 <-  OpenMx::mxModel("MZDZModel", M1, MZ, DZ,
mxFitFunctionMultigroup( c("MZ","DZ"))
)
#
#
# fit the model
Model_1out <- mxRun(Model_1, intervals=FALSE, silent = TRUE)
#
#summary(Model_1out)
sat_1out <- mxRefModels(Model_1out, run=TRUE)
mxCompare(sat_1out, Model_1out)
#
#
Model_1b <- omxSetParameters(Model_1out, labels=c('b1'), free=FALSE, values=c(0))
Model_1b_out <- mxRun(Model_1b, intervals=TRUE, silent = TRUE)
mxCompare(Model_1out, Model_1b_out)
Model_1g <- omxSetParameters(Model_1out, labels=c('g1'), free=FALSE, values=c(0))
Model_1g_out <- mxRun(Model_1g, intervals=TRUE, silent = TRUE)
mxCompare(Model_1out, Model_1g_out)
Model_1bg <- omxSetParameters(Model_1out, labels=c('g1','b1'), free=FALSE, values=c(0))
Model_1bg_out <- mxRun(Model_1bg, intervals=TRUE, silent = TRUE)
mxCompare(Model_1out, Model_1bg_out)
#
mxRefModels(Model_1out, run=TRUE) -> sat_1out
mxCompare(sat_1out, Model_1out)
#
#
# -----------------------------------------------   vars
varnames=c('pht1','pht2')#
#
# the model to calculate expected summary statistics
# this is the twin model phenotypic
# [1] "pht1"   "pht2"   "pgsm"   "pgsf"   "pgst1"  "pgsnt1" "pgst2"  "pgsnt2" "pgsmf"  "mpgst"
# [1] "pgsm"  "pgsf"  "pgst1" "pgst2" "pht1"  "pht2"  "pgsmf" "mpgst"
# a model the data, the fit function (MZ)
MZmodel <- OpenMx::mxModel("MZ",
#
# Matrix expMean for expected mean vector for MZ and DZ twins
mxMatrix(type="Full", nrow=1, ncol=4, free=FALSE, labels=c("data.pgst1","data.pgst2","data.pgsm","data.pgsf"), name="pred"),
mxMatrix(type="Full", nrow=1, ncol=4, free=c(TRUE,TRUE,TRUE,TRUE), values=c(0,0,0,0),
labels=c("bpgst","bpgsb","bpgsg","bpgsg"), name="bs1"),
mxMatrix(type="Full", nrow=1, ncol=4, free=TRUE, values=c(0,0,0,0),
labels=c("bpgsb","bpgst","bpgsg","bpgsg"), name="bs2"),
mxMatrix(type="Full", nrow=1, ncol=1,
free=c(TRUE),values=c(0),labels=c("b0"),
name="Int"),
mxAlgebra(expression=cbind(b0+pred%*%t(bs1), b0+pred%*%t(bs2)), name='expMean'),
mxData(observed=phdatmz_e, type="raw"),
mxExpectationNormal(covariance="ACE.expCovMZ",
means = "expMean", varnames),
mxFitFunctionML()
)
# a model the data, the fit function (DZ)
DZmodel <- OpenMx::mxModel("DZ",
#
# Matrix expMean for expected mean vector for MZ and DZ twins
mxMatrix(type="Full", nrow=1, ncol=4, free=FALSE, labels=c("data.pgst1","data.pgst2","data.pgsm","data.pgsf"), name="pred"),
mxMatrix(type="Full", nrow=1, ncol=4, free=c(TRUE,TRUE,TRUE,TRUE), values=c(0,0,0,0),
labels=c("bpgst","bpgsb","bpgsg","bpgsg"), name="bs1"),
mxMatrix(type="Full", nrow=1, ncol=4, free=TRUE, values=c(0,0,0,0),
labels=c("bpgsb","bpgst","bpgsg","bpgsg"), name="bs2"),
mxMatrix(type="Full", nrow=1, ncol=1,
free=c(TRUE),values=c(0),labels=c("b0"),
name="Int"),
mxAlgebra(expression=cbind(b0+pred%*%t(bs1), b0+pred%*%t(bs2)), name='expMean'),
mxData(observed=phdatdz_e, type="raw"),
mxExpectationNormal(covariance="ACE.expCovDZ",
means = "expMean", varnames),
mxFitFunctionML()
)
varnames=c('pht1','pht2')#
#
# the model to calculate expected summary statistics
# this is the twin model phenotypic
# [1] "pht1"   "pht2"   "pgsm"   "pgsf"   "pgst1"  "pgsnt1" "pgst2"  "pgsnt2" "pgsmf"  "mpgst"
# [1] "pgsm"  "pgsf"  "pgst1" "pgst2" "pht1"  "pht2"  "pgsmf" "mpgst"
# a model the data, the fit function (MZ)
MZmodel <- OpenMx::mxModel("MZ",
#
# Matrix expMean for expected mean vector for MZ and DZ twins
mxMatrix(type="Full", nrow=1, ncol=4, free=FALSE, labels=c("data.pgst1","data.pgst2","data.pgsm","data.pgsf"), name="pred"),
mxMatrix(type="Full", nrow=1, ncol=4, free=c(TRUE,TRUE,TRUE,TRUE), values=c(0,0,0,0),
labels=c("bpgst","bpgsb","bpgsg","bpgsg"), name="bs1"),
mxMatrix(type="Full", nrow=1, ncol=4, free=TRUE, values=c(0,0,0,0),
labels=c("bpgsb","bpgst","bpgsg","bpgsg"), name="bs2"),
mxMatrix(type="Full", nrow=1, ncol=1,
free=c(TRUE),values=c(0),labels=c("b0"),
name="Int"),
mxAlgebra(expression=cbind(b0+pred%*%t(bs1), b0+pred%*%t(bs2)), name='expMean'),
mxData(observed=phdatmz_e, type="raw"),
mxExpectationNormal(covariance="SAT.expCovMZ",
means = "expMean", varnames),
mxFitFunctionML()
)
# a model the data, the fit function (DZ)
DZmodel=OpenMx::mxModel("DZ",
#
# Matrix expMean for expected mean vector for MZ and DZ twins
mxMatrix(type="Full", nrow=1, ncol=4, free=FALSE, labels=c("data.pgst1","data.pgst2","data.pgsm","data.pgsf"), name="pred"),
mxMatrix(type="Full", nrow=1, ncol=4, free=c(TRUE,TRUE,TRUE,TRUE), values=c(0,0,0,0),
labels=c("bpgst","bpgsb","bpgsg","bpgsg"), name="bs1"),
mxMatrix(type="Full", nrow=1, ncol=4, free=TRUE, values=c(0,0,0,0),
labels=c("bpgsb","bpgst","bpgsg","bpgsg"), name="bs2"),
mxMatrix(type="Full", nrow=1, ncol=1,
free=c(TRUE),values=c(0),labels=c("b0"),
name="Int"),
mxAlgebra(expression=cbind(b0+pred%*%t(bs1), b0+pred%*%t(bs2)), name='expMean'),
mxData(observed=phdatdz_e, type="raw"),
mxExpectationNormal(covariance="SAT.expCovDZ",
means = "expMean", varnames),
mxFitFunctionML()
)
varnames <- c('pht1','pht2')#
#
# the model to calculate expected summary statistics
# this is the twin model phenotypic
# [1] "pht1"   "pht2"   "pgsm"   "pgsf"   "pgst1"  "pgsnt1" "pgst2"  "pgsnt2" "pgsmf"  "mpgst"
# [1] "pgsm"  "pgsf"  "pgst1" "pgst2" "pht1"  "pht2"  "pgsmf" "mpgst"
nphen1 <- 1
nphen2 <- 2
DZModel  <-  OpenMx::mxModel("DZonly",
#
# Matrices a, c, and e to store the a, c, and e path coefficients
mxMatrix(type="Stand", nrow=nphen2, ncol=nphen2,
free=c(TRUE), values=c(.25),
labels=c("rdz"),name="Rdz"),
mxMatrix(type="Diag", nrow=nphen2, ncol=nphen2,
free=c(TRUE), values=c(.7),
labels=c("sd","sd"),name="SD"),
#
#
# Matrix expCovMZ for expected covariance matrix for DZ twins
#
mxAlgebra( expression=
SD%*%Rdz%*%SD,,name="expCovDZ"),
#
# Matrix expMean for expected mean vector for DZ twins
#
mxMatrix(type="Full", nrow=1, ncol=4, free=FALSE, labels=c("data.pgst1","data.pgst2","data.pgsm","data.pgsf"), name="pred"),
mxMatrix(type="Full", nrow=1, ncol=4, free=c(TRUE,TRUE,TRUE,TRUE), values=c(0,0,0,0),
labels=c("bpgst","bpgsb","bpgsg","bpgsg"), name="bs1"),
mxMatrix(type="Full", nrow=1, ncol=4, free=TRUE, values=c(0,0,0,0),
labels=c("bpgsb","bpgst","bpgsg","bpgsg"), name="bs2"),
mxMatrix(type="Full", nrow=1, ncol=1,
free=c(TRUE),values=c(0),labels=c("b0"),
name="B0"),
mxAlgebra(expression=cbind(B0+pred%*%t(bs1), B0+pred%*%t(bs2)), name='expMean'),
mxData(observed=phdatdz_e, type="raw"),
mxExpectationNormal(covariance="expCovDZ",
means ="expMean", varnames),
mxFitFunctionML()
)
# Model_4 <-  OpenMx::mxModel(name="DZ1SAT", DZModel)
Model_4 <-  OpenMx::mxModel(DZModel)
# fit the model
Model_4out <- mxRun(Model_4, silent = TRUE)
Model_4g <- omxSetParameters(Model_4out, labels='bpgsg', values=0, free=FALSE)
Model_4g_out = mxRun(Model_4g, silent = TRUE)
#
Model_4b=omxSetParameters(Model_4out, labels='bpgsb', values=0, free=FALSE)
Model_4b_out <- mxRun(Model_4b, silent = TRUE)
# "bpgsb","bpgsg"
Model_4bg <- omxSetParameters(Model_4out, labels=c('bpgsb','bpgsg'), free=FALSE, values=c(0))
Model_4bg_out <- mxRun(Model_4bg, silent = TRUE)
# Power
ncp_tmp <- c(
mxCompare(Model_1b_out, Model_1bg_out)[2,7],
mxCompare(Model_1g_out, Model_1bg_out)[2,7],
mxCompare(Model_1out, Model_1g_out)[2,7],
mxCompare(Model_1out, Model_1b_out)[2,7],
mxCompare(Model_4b_out, Model_4bg_out)[2,7],
mxCompare(Model_4g_out, Model_4bg_out)[2,7],
mxCompare(Model_4out, Model_4g_out)[2,7],
mxCompare(Model_4out, Model_4b_out)[2,7]
)
ncp_power_tmp <- sapply(ncp_tmp, function(ncp) {
gnome_power(alpha, 1, ncp)
})
# Estimates
estimates_tmp <- c(
summary(Model_1b_out)$parameters[8, "Estimate"], # g1 - CT Model 1 CT only
summary(Model_1g_out)$parameters[8,'Estimate'], # b1 - SI Model 1 SI only
summary(Model_1out)$parameters[9,'Estimate'], # g1 - CT Model 1 both
summary(Model_1out)$parameters[8,'Estimate'], # b1 - SI Model 1 both
summary(Model_4b_out)$parameters[4, 'Estimate'], # bpgsg - CT Model 4 CT only
summary(Model_4g_out)$parameters[4, 'Estimate'], # bpgsb - SI Model 4 SI only
summary(Model_4out)$parameters[5, 'Estimate'], # bpgsg - CT Model 4
summary(Model_4out)$parameters[4, 'Estimate'] # bpgsb - SI Model 4
)
mxkeep[counter_within, ] <- c(ncp_power_tmp, estimates_tmp)
}
# For mxkeep
jpow <- 1:8
jest <- 9:16
row_index <- counter_overall - n_set + 1
if (assortm_logical == TRUE) {
# Execute these lines when assortm_logical is TRUE
final_mx_estimates[row_index : counter_overall, 1:10] <- setkeep[, 1:10]
final_mx_power[row_index : counter_overall, 1:10] <- setkeep[, 1:10]
final_mx_estimates[row_index : counter_overall, 11:18] <- round(mxkeep[, jest], 3)
final_mx_power[row_index : counter_overall, 11:18] <- round(mxkeep[, jpow], 3)
} else {
# Execute these lines when assortm_logical is FALSE
final_mx_estimates[row_index : counter_overall, 1:11] <- setkeep[, 1:11]
final_mx_power[row_index : counter_overall, 1:11] <- setkeep[, 1:11]
final_mx_estimates[row_index : counter_overall, 12:19] <- round(mxkeep[, jest], 3)
final_mx_power[row_index : counter_overall, 12:19] <- round(mxkeep[, jpow], 3)
}
counter_within = 0 # reset set counter for each PGS setting
}
# Re-name columns
ifelse(assortm_logical,
setnames <- c('nmz','ndz','a','c','e','g','b','x','PGS','A'),
setnames <- c('nmz','ndz','a','c','e','g','b','x','PGS','A','assortm'))
colnames(final_mx_estimates) <- c(setnames, paste0("e", 1:8))
colnames(final_mx_power) <- c(setnames, paste0("p", 1:8))
# Use effect size function on the data sets
final_mx_estimates <- final_mx_estimates %>%
mutate(Smz = gnome_effect(a = a, c = c, e = e, g = g, b = b)$mz,
Sdz = gnome_effect(a = a, c = c, e = e, g = g, b = b)$dz)
final_mx_power <- final_mx_power %>%
mutate(Smz = gnome_effect(a = a, c = c, e = e, g = g, b = b)$mz,
Sdz = gnome_effect(a = a, c = c, e = e, g = g, b = b)$dz)
return(list(power = final_mx_power, params = final_mx_estimates))
}
gnome_power <- function(alpha = .05, df, ncp) {
critical_chi2 <- qchisq(alpha, df, lower.tail = F)
if (abs(ncp) < .0001) { ncp = 0 }
power <- pchisq(critical_chi2, df, ncp, lower.tail = F)
power
}
gnome_effect <- function(a, c, e, g, b, varA = 1, varC = 1, varE = 1) {
# Phenotypic covariances for MZ and DZ
smz = 2 * (g + a/2 + b/2)**2*varA + (a*varA/2 + b*varA/2) * a + (a*varA/2 + b*varA/2) * b + c**2*varC + e**2
sdz = 2 * (g + a/2 + b/2)**2*varA + a**2*varA/2 + b**2*varA/2 + c**2*varC + e**2*varE
# Variance Increase
varPh_noAC <- a**2*varA + c**2*varC + e**2*varE
effect_mz <- (smz - varPh_noAC) / varPh_noAC
effect_dz <- (sdz - varPh_noAC) / varPh_noAC
effect = list(mz = effect_mz, dz = effect_dz)
return(effect)
}
sample_list <- list()
for (n in unique_sample_sizes) {
if (length(sample_list) < which(unique_sample_sizes == n)) {
result <- gnome_mx_simulation(nmz = n, ndz = n, ct = 0.03, si = 0.03, nloci = 100, npgsloci = 10)
sample_list <- append(sample_list, list(result))
}
}
View(sample_list)
# Extract power and parameters
sample_power <- do.call(rbind, lapply(sample_list, `[[`, "power"))
sample_params <- do.call(rbind, lapply(sample_list, `[[`, "params"))
sample_power
# Extract power and parameters
sample_power <- do.call(rbind, lapply(sample_list, `[[`, "power"))
sample_params <- do.call(rbind, lapply(sample_list, `[[`, "params"))
# install.packages("~/GitHub/gnomesims_0.0.0.9000.tar.gz", repos = NULL, type = "source")
devtools::install_github("josefinabernardo/gnomesims", force = TRUE)
# Revision - Create data for different sample sizes
# Define sample sizes
sample_sizes <- c(100, seq(10000, 50000, 10000))
sample_sizes_dz <- sample_sizes/2
unique_sample_sizes <- unique(c(sample_sizes, sample_sizes_dz))
sample_list <- list()
for (n in unique_sample_sizes) {
if (length(sample_list) < which(unique_sample_sizes == n)) {
result <- gnome_mx_simulation(nmz = n, ndz = n, ct = 0.03, si = 0.03, nloci = 100, npgsloci = 10)
sample_list <- append(sample_list, list(result))
}
}
# Extract power and parameters
sample_power <- do.call(rbind, lapply(sample_list, `[[`, "power"))
sample_params <- do.call(rbind, lapply(sample_list, `[[`, "params"))
write.csv(sample_power, "sample_power.csv", row.names = TRUE)
write.csv(sample_params, "sample_params.csv", row.names = TRUE)
# Start here if files are already created
paper_power <- read.csv("paper_mx_power.csv")
paper_estimates <- read.csv("paper_mx_estimates.csv")
# install.packages("~/GitHub/gnomesims_0.0.0.9000.tar.gz", repos = NULL, type = "source")
devtools::install_github("josefinabernardo/gnomesims", force = TRUE)
library(gnomesims)
library(OpenMx)
R.version
# Install all packages
devtools::install_github("josefinabernardo/gnomesims")
library(gnomesims)
library(OpenMx)
# Run function for detailed lots in running text
paper_data <- gnomesims::gnome_mx_simulation(ct = seq(0,.1,.02), si = seq(0,.1,.02),
nloci = 100,
npgsloci = c(2, 5, 10, 15))
# install.packages("~/GitHub/gnomesims_0.0.0.9000.tar.gz", repos = NULL, type = "source")
devtools::install_github("josefinabernardo/gnomesims", force = TRUE)
library(gnomesims)
detach("package:gnomesims", unload = TRUE)
# install.packages("~/GitHub/gnomesims_0.0.0.9000.tar.gz", repos = NULL, type = "source")
devtools::install_github("josefinabernardo/gnomesims", force = TRUE)
library(OpenMx)
library(tidyverse)
# Revision - Create data for different sample sizes
# Define sample sizes
sample_sizes <- c(100, seq(10000, 50000, 10000))
sample_sizes_dz <- sample_sizes/2
unique_sample_sizes <- unique(c(sample_sizes, sample_sizes_dz))
sample_list <- list()
for (n in unique_sample_sizes) {
if (length(sample_list) < which(unique_sample_sizes == n)) {
result <- gnome_mx_simulation(nmz = n, ndz = n, ct = 0.03, si = 0.03, nloci = 100, npgsloci = 10)
sample_list <- append(sample_list, list(result))
}
}
library(gnomesims)
# Revision - Create data for different sample sizes
# Define sample sizes
sample_sizes <- c(100, seq(10000, 50000, 10000))
sample_sizes_dz <- sample_sizes/2
unique_sample_sizes <- unique(c(sample_sizes, sample_sizes_dz))
sample_list <- list()
for (n in unique_sample_sizes) {
if (length(sample_list) < which(unique_sample_sizes == n)) {
result <- gnome_mx_simulation(nmz = n, ndz = n, ct = 0.03, si = 0.03, nloci = 100, npgsloci = 10)
sample_list <- append(sample_list, list(result))
}
}
# Extract power and parameters
sample_power <- do.call(rbind, lapply(sample_list, `[[`, "power"))
sample_params <- do.call(rbind, lapply(sample_list, `[[`, "params"))
write.csv(sample_power, "sample_power.csv", row.names = TRUE)
write.csv(sample_params, "sample_params.csv", row.names = TRUE)
# Start here if files are already created
paper_power <- read.csv("paper_mx_power.csv")
paper_estimates <- read.csv("paper_mx_estimates.csv")
2*(0.03+sqrt(4)/2+0.03/2)^2+(sqrt(.4)/2+0.03/2)*(sqrt(.4)+0.03)+0.6
library(gnomesims)
library(OpenMx)
library(tidyverse)
# Varying sample size
sample_sizes <- c(100, seq(10000, 50000, 10000))
sample_sizes_dz <- sample_sizes/2
unique_sample_sizes <- unique(c(sample_sizes, sample_sizes_dz))
sample_list <- list()
for (n in unique_sample_sizes) {
if (length(sample_list) < which(unique_sample_sizes == n)) {
result <- gnome_mx_simulation(nmz = n, ndz = n, ct = 0.03, si = 0.03, nloci = 100, npgsloci = 40)
sample_list <- append(sample_list, list(result))
}
}
unique_sample_sizes
# Extract power and parameters
sample_power <- do.call(rbind, lapply(sample_list, `[[`, "power"))
sample_params <- do.call(rbind, lapply(sample_list, `[[`, "params"))
sample_power
write.csv(sample_power, "sample_power.csv", row.names = TRUE)
write.csv(sample_params, "sample_params.csv", row.names = TRUE)
